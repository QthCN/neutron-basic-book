## 协议栈中的收包/发包

本节我们会讲一下在内核中，一个数据包从网卡进入后会走什么样的路径，以及当发送一个数据包的时候这个数据包会的走什么样的路径。除此以外当我们对数据包的收发路径大概清楚后，我们会看下Neutron中用到的veth设备在内核是如何实现的，另外会讲下常见的提升收发包速率的方法。


### PCIe设备驱动的加载

在前面一节中我们提到了内核的module机制以及硬件中断的处理函数，另外也介绍了net_device数据结构。这里我们来把这几个东西串起来。

当一台物理机上插了块网卡的时候，网卡现在都是走PCIe口插在主板上的。假设现在内核中没有任何的网卡驱动，所以当开机的时候内核会让PCIe子系统自己去发现连在上面的设备，于是PCIe子系统发现了这个网卡。PCIe是个通用的标准，虽然此时PCIe不知道如何去使用这个设备，但是通过PCIe的标准PCIe子系统可以询问这个网卡设备获取这个网卡设备的基本信息，在这个信息里有一个很重要的ID，这个ID是全球唯一的，只属于这个网卡的型号。然后PCIe虽然不知道怎么使用这个设备，但是既然知道了其ID，所以就在某个内核中存了个信息，内容类似为：“我这里有个ID位XXX的设备。”。接着我们来加载驱动，加载的方法就是之前讲的module机制，通过insmod的方法我们的驱动就加载了，然后对应的init方法会调用。由于这个驱动知道自己的网卡是个PCIe设备，所以其init方法里会直接调用内核提供的pci_module_init函数。pci_module_init函数是内核提供的，其实现在目前我们可以简单的理解为：它会去查看PCIe发现的设备列表，遍历所有设备，然后判断被遍历的设备的ID是不是和驱动代码里写的ID一样，如果这两个ID是一样的，那么这个设备就有对应的驱动了。一个实际的例子如下：

```
static int __init e100_init_module(void)
{
    return pci_module_init(&e100_driver);
}

static struct pci_driver e100_driver = {
     .name = DRV_NAME,
     .id_table = e100_id_table,
     .probe = e100_probe,
     .remove = __devexit_p(e100_remove),
#ifdef CONFIG_PM
     .suspend = e100_suspend,
     .resume = e100_resume,
#endif
};
```

我们的module的init方法为e100_init_module，其直接调用了pci_module_init去匹配对应的设备。e100_driver是我们驱动实现的，注意这里的id_table属性就是我们的PCIe的每个设备型号全球唯一的ID。

现在我们知道了设备和驱动是如何联系起来的，接着我们来看我们的net_device如何被建立。这里还是要回到pci_module_init上，我们可以看到我们的驱动实现了一个pci_driver结构体，对于每个PCIe的驱动，都需要实现这个结构体的方法。内核约定在pci_module_init被调用的时候，会调用pci_driver结构体的probe方法，我们可以将probe看成是我们驱动和设备关联后执行的一个初始化方法。至于probe中做什么事情就有PCIe的驱动自己实现了。对于网卡驱动来说一般会做下面的事情：

* 生成net_device结构体并注册到全局链表上
* 驱动会设置net_device的相关属性，尤其是提供各种ops属性的实现

我们来详细看下probe，这里来看一个实际的例子e1000，在内核源码中的路径在drivers/net/ethernet/intel/e1000下。

首先来看其pci_driver结构体：

```
static struct pci_driver e1000_driver = {
    .name     = e1000_driver_name,
    .id_table = e1000_pci_tbl,
    .probe    = e1000_probe,
    .remove   = e1000_remove,
#ifdef CONFIG_PM
    /* Power Management Hooks */
    .suspend  = e1000_suspend,
    .resume   = e1000_resume,
#endif
    .shutdown = e1000_shutdown,
    .err_handler = &e1000_err_handler
};
```

对应的probe方法我们看到是e1000_probe，我们来看下其实现。代码为：

```
static int e1000_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
{
    struct net_device *netdev;
    struct e1000_adapter *adapter;
    struct e1000_hw *hw;
 
    static int cards_found = 0;
    static int global_quad_port_a = 0; /* global ksp3 port a indication */
    int i, err, pci_using_dac;
    u16 eeprom_data = 0;
    u16 tmp = 0;
    u16 eeprom_apme_mask = E1000_EEPROM_APME;
    int bars, need_ioport;
```

这里声明及初始化了一些变量，接着的代码为：

```
/* do not allocate ioport bars when not needed */
need_ioport = e1000_is_need_ioport(pdev);
if (need_ioport) {
    bars = pci_select_bars(pdev, IORESOURCE_MEM | IORESOURCE_IO);
    err = pci_enable_device(pdev);
} else {
    bars = pci_select_bars(pdev, IORESOURCE_MEM);
    err = pci_enable_device_mem(pdev);
}
if (err)
    return err;
 
err = pci_request_selected_regions(pdev, bars, e1000_driver_name);
if (err)
    goto err_pci_reg;
 
pci_set_master(pdev);
err = pci_save_state(pdev);
if (err)
    goto err_alloc_etherdev;
```

这些代码和cpi有关，但是不是我们的重点。我们继续看代码：

```
err = -ENOMEM;
netdev = alloc_etherdev(sizeof(struct e1000_adapter));
if (!netdev)
    goto err_alloc_etherdev;
```

可以看到这里调用了内核提供的alloc_etherdev分配了一个以太网的net_device结构体。alloc_etherdev实际上是alloc_netdev的一个封装，alloc_netdev会分配已个最基本的net_device结构，然后alloc_etherdev在调用alloc_netdev的基础上会对这个net_device设置一些以太网相关的属性，这些以太网相关属性的初始化是通过调用ether_setup实现的。另外我们可以看到alloc_etherdev传递了一个e1000_adapter结构体的大小，这个大小是分配net_device的时候用于决定私有数据大小的。现在我们的net_device已经出现，只不过是一个通用的以太网的net_device结构体。我们继续看代码：

```
SET_NETDEV_DEV(netdev, &pdev->dev);

pci_set_drvdata(pdev, netdev);
adapter = netdev_priv(netdev);
adapter->netdev = netdev;
adapter->pdev = pdev;
adapter->msg_enable = netif_msg_init(debug, DEFAULT_MSG_ENABLE);
adapter->bars = bars;
adapter->need_ioport = need_ioport;
 
hw = &adapter->hw;
hw->back = adapter;
```

这里的代码主要是私有数据结构的初始化，私有数据结构所在的内存大小就是上面说的alloc_etherdev传递e1000_adapter结构体的大小。私有的我们就不去细看了，大家可以注意下netdev_priv，在大家自己去看网络相关的代码的时候看到netdev_priv就知道返回的指针是指向net_device的私有数据内存的指针。继续看代码，我们跳过那些私有的代码：

```
netdev->netdev_ops = &e1000_netdev_ops;
e1000_set_ethtool_ops(netdev);
netdev->watchdog_timeo = 5 * HZ;
netif_napi_add(netdev, &adapter->napi, e1000_clean, 64);
 
strncpy(netdev->name, pci_name(pdev), sizeof(netdev->name) - 1);
```

我们可以看到我们的netdev_ops和ethtool_ops都在这里被驱动给设置了。关于napi相关的我们后面会详细讲到。e1000_netdev_ops的内容为：

```
static const struct net_device_ops e1000_netdev_ops = {
    .ndo_open       = e1000_open,
    .ndo_stop       = e1000_close,
    .ndo_start_xmit     = e1000_xmit_frame,
    .ndo_get_stats      = e1000_get_stats,
    .ndo_set_rx_mode    = e1000_set_rx_mode,
    .ndo_set_mac_address    = e1000_set_mac,
    .ndo_tx_timeout     = e1000_tx_timeout,
    .ndo_change_mtu     = e1000_change_mtu,
    .ndo_do_ioctl       = e1000_ioctl,
    .ndo_validate_addr  = eth_validate_addr,
    .ndo_vlan_rx_add_vid    = e1000_vlan_rx_add_vid,
    .ndo_vlan_rx_kill_vid   = e1000_vlan_rx_kill_vid,
#ifdef CONFIG_NET_POLL_CONTROLLER
    .ndo_poll_controller    = e1000_netpoll,
#endif
    .ndo_fix_features   = e1000_fix_features,
    .ndo_set_features   = e1000_set_features,
};
```

这里的一些方法（比如ndo_start_xmit）会在后面的小节中讲到。接着看我们的probe方法可以看到：

```
strcpy(netdev->name, "eth%d");
err = register_netdev(netdev);
if (err)
    goto err_register;
```

这里可以看到我们的设备名字被设置了，重点可以看到register_netdev，其将我们的net_device结构体加入了全局的链表中，此时我们调用ip link show的时候后者就会遍历全局的链表输出我们的设备了。

probe的代码在e1000中就基本上这些，这里可能有人会有疑问，我们的net_device已经建立好了，但是我们的中断处理函数和中断向量号的绑定是在哪里设置的呢？目前代码看下来我们的probe并没有做这个事情，此时如果网卡收到了包产生了中断号，但由于这个中断号并没有对应的处理函数所以内核是收不到包的。在e1000的代码中，中断向量号和中断处理函数的绑定是在netdev_ops的ndo_open方法中设置的，在e1000_open中我们可以看到如下代码：

```
static int e1000_request_irq(struct e1000_adapter *adapter)
{
    struct net_device *netdev = adapter->netdev;
    irq_handler_t handler = e1000_intr;
    int irq_flags = IRQF_SHARED;
    int err;
 
    err = request_irq(adapter->pdev->irq, handler, irq_flags, netdev->name,
                      netdev);
    if (err) {
        e_err(probe, "Unable to allocate interrupt Error: %d\n", err);
    }   
 
    return err;
}
```

request_irq这里设置了adapter->pdev->irq这个中断向量号和中断handler的关系。另外通过上面的代码我们也清楚了，当我们想要学习一个驱动的收包代码的时候，e1000_intr会是我们的一个很好的入口：）。

关于PCIe的网卡驱动加载我们就讲这么多，重要的是要记住net_device是如何生成的以及其在哪里进行了ops的函数指针的赋值。


### 收包路径

现在我们来讲收包。我们会看到数据包如何从网卡进入内核，然后开始走协议栈一层一层往上。我们不会将高层协议栈中对于收包的处理，因为对于我们学习Neutron来说那个是应用的事情了，但是我想如果能理解小秦下面讲的基础收包路径，那么大家很容易能继续探索协议栈上层收包的实现的。

