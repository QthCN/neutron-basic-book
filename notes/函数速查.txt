函数：
request_irq:    注册中断
free_irq:   解绑注册的中断
request_region: 注册IO到内存的映射
release_region: 解绑IO到内存的映射
net_dev_init:   系统启动阶段负责初始化network子系统
pci_register_driver:    驱动程序调用，用于将其注册一个pci_driver在相应的PCI的链表上
pci_unregister_driver:  移除pci_driver
pci_module_init:    对pci_register_driver的一个封装，功能类似
module_init:    注册一个module，一般是注册驱动
module_exit:    移除一个module，一般是卸载驱动
init_module:    module提供，用于被module_init调用
cleanup_module: module提供，用于被module_exit调用
alloc_netdev:   分配一个net_device数据结构。这个数据结构需要由驱动去初始化。调用的时候需要提供private data大小、dev的名字（一般是eth%d）以及setup routine。setup routine能对net_device做基本的初始化
dev_alloc_name: 用于生成alloc_netdev名字参数需要的%d
alloc_etherdev: 对alloc_netdev的封装，专门用于产生以太网设备的net_device。比如其传递的dev名字、setup routine都是以太网相关的。实现为：return alloc_netdev(sizeof_priv, "eth%d", ether_setup)
register_netdevice: 将一个net_device注册到数据库（链表）中。会调用net_device的init函数
netdev_run_todo:    register_netdevice只会做简单的事情，大部分注册相关的事情由netdev_run_todo完成
netdev_priv:    获取private data的头部指针
in_interrupt:   判断此CPU此时是否运行在中断中，包括硬件中断和软件中断
in_softirq: 判断此CPU此时是否在处理softirq
in_irq: 判断此CPU此时是否在处理硬件中断
softirq_pending:    判断某个CPU是否有需要处理的软中断
local_softirq_pending:  判断此CPU是否要要处理的软中断
preempt_disable:    对当前task停止抢占
preempt_enable_no_resched:  对是否允许抢占的计数器减一，当减为0的时候就允许抢占
preempt_enable: 对是否允许抢占的计数器减一，当减为0的时候就允许抢占。并且其会判断是否已经为0，如果是的话主动调用schedule()交出时间片
do_bottom_half: 开始准备执行下半区
run_bottom_half:    执行下半区。会检查哪些flag被标记了，然后找到其注册的下半区handler，然后执行它
net_rx_action:  接受包的软中断handler，遍历poll_list中的net_device，调用其poll方法。对于老的驱动poll方法由内核提供，对于NAPI则由驱动自己提供
net_tx_action:  发送包的软中断handler
__do_softirq:   处理软中断的函数，会遍历pending的软中断，调用对应的handler（比如net_rx_action、net_tx_action）
netif_running:  检查__LINK_STATE_STAR是否设置
netif_rx:   non-NAPI用于进一步处理二层包的入口方法，老的驱动通过这个函数将数据包放到softnet_data的input_pkt_queue尾部，同时将backuplog_dev放到poll_list中等待下半区处理。
netif_rx_schedule/__netif_rx_schedule：将net_device放到poll_list中。对于NAPI在中断handler中会调用这个方法，对于non-NAPI则是由netif_rx调用，netif_rx中会的调用这个方法
netif_rx_complete/__netif_rx_complete：poll_list中的net_device在poll处理后，如果没有数据包了则调用这个方法
netif_poll_disable/netif_poll_enable：net_device在被加入到poll_list之前，会检查__LINK_STATE_RX_SCHED这个flag是否设置，如果设置了则认为已经在poll_list中了，则不会再次添加。引入如果想disable一个net_device，可以直接设置则个flag，从此其就不会被放入到poll_list中，于是其收到的包也就一直在设备内存中，不会被内核处理
process_backlog：non-NAPI默认的poll方法
netif_receive_skb：poll方法中，让数据包开始协议栈处理的入口函数。无论是non-NAPI还是NAPI都是通过这个函数传递sk_buff，然后通过协议栈处理这个sk_buff的。



全局变量：
irq_desc:   指向IRQ描述符表

数据结构：
irq_action: 存放IRQ和handle等其余相关中断处理需要的信息，依附在irq_desc上
net_device: 网络设备数据结构
pci_dev:    每个PCI设备在内核中的数据结构，类似于net_device
pci_driver: 驱动程序实现的用于PCI设备的驱动，提供probe、remove、id_table等属性。probe会建立对应的net_device结构
pci_device_id:  PCI设备的唯一公开ID。PCI总线根据连在其上面的设备的pci_device_id依次遍历注册的pci_driver的id_table，发现ID符合的pci_driver后调用其probe方法注册设备
pci_dev:    代表一个PCI设备
