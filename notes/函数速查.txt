函数：
request_irq:    注册中断
free_irq:   解绑注册的中断
request_region: 注册IO到内存的映射
release_region: 解绑IO到内存的映射
net_dev_init:   系统启动阶段负责初始化network子系统
pci_register_driver:    驱动程序调用，用于将其注册一个pci_driver在相应的PCI的链表上
pci_unregister_driver:  移除pci_driver
pci_module_init:    对pci_register_driver的一个封装，功能类似
module_init:    注册一个module，一般是注册驱动
module_exit:    移除一个module，一般是卸载驱动
init_module:    module提供，用于被module_init调用
cleanup_module: module提供，用于被module_exit调用
alloc_netdev:   分配一个net_device数据结构。这个数据结构需要由驱动去初始化。调用的时候需要提供private data大小、dev的名字（一般是eth%d）以及setup routine。setup routine能对net_device做基本的初始化
dev_alloc_name: 用于生成alloc_netdev名字参数需要的%d
alloc_etherdev: 对alloc_netdev的封装，专门用于产生以太网设备的net_device。比如其传递的dev名字、setup routine都是以太网相关的。实现为：return alloc_netdev(sizeof_priv, "eth%d", ether_setup)
register_netdevice: 将一个net_device注册到数据库（链表）中。会调用net_device的init函数
netdev_run_todo:    register_netdevice只会做简单的事情，大部分注册相关的事情由netdev_run_todo完成
netdev_priv:    获取private data的头部指针
in_interrupt:   判断此CPU此时是否运行在中断中，包括硬件中断和软件中断
in_softirq: 判断此CPU此时是否在处理softirq
in_irq: 判断此CPU此时是否在处理硬件中断
softirq_pending:    判断某个CPU是否有需要处理的软中断
local_softirq_pending:  判断此CPU是否要要处理的软中断
preempt_disable:    对当前task停止抢占
preempt_enable_no_resched:  对是否允许抢占的计数器减一，当减为0的时候就允许抢占
preempt_enable: 对是否允许抢占的计数器减一，当减为0的时候就允许抢占。并且其会判断是否已经为0，如果是的话主动调用schedule()交出时间片
do_bottom_half: 开始准备执行下半区
run_bottom_half:    执行下半区。会检查哪些flag被标记了，然后找到其注册的下半区handler，然后执行它
net_rx_action:  接受包的软中断handler
net_tx_action:  发送包的软中断handler
__do_softirq:   处理软中断的函数，会遍历pending的软中断，调用对应的handler（比如net_rx_action、net_tx_action）




全局变量：
irq_desc:   指向IRQ描述符表

数据结构：
irq_action: 存放IRQ和handle等其余相关中断处理需要的信息，依附在irq_desc上
net_device: 网络设备数据结构
pci_dev:    每个PCI设备在内核中的数据结构，类似于net_device
pci_driver: 驱动程序实现的用于PCI设备的驱动，提供probe、remove、id_table等属性。probe会建立对应的net_device结构
pci_device_id:  PCI设备的唯一公开ID。PCI总线根据连在其上面的设备的pci_device_id依次遍历注册的pci_driver的id_table，发现ID符合的pci_driver后调用其probe方法注册设备
pci_dev:    代表一个PCI设备
